# 算法

## 递归算法



```js
// 遍历 DOM 树。DOM 🌲根节点 document ，我们要寻找的 id='d-cal'
function getElementById(node, id){
    // 当前结点不存在，已经到了叶子结点了还没有找到，返回 null
    if(!node) return null;
    // 当前结点的 id 符合查找条件，返回当前结点
    if(node.id === id) return node;
    for(var i = 0; i < node.childNodes.length; i++){
        var found = getElementById(node.childNodes[i], id);
        if(found) return found;
    }
    return null;
}
getElementById(document, "d-cal");
```

```JS
// 非递归实现
function getElementById(node, id) {
  while(node) {
    if (node.id === id) return node
    node = nextElement(node)
  }
  return null
}

function nextElement(node) {
  // 判断是否存在子节点
  if (node.children.length > 0) {
    return node.children[0]
  }
  // 再判断是否存在相邻节点
  if (node.nextElementSibling) {
    return node.nextElementSibling
  }
  // 查找父节点的相邻节点
  while(node.parentNode) {
    if (node.parentNode.nextElementSibling) {
      return node.parentNode.nextElementSibling
    }
    node = node.parentNode
  }
  return null
}
```

**递归算法**是一种直接或者间接调用自身函数或者方法的算法。

- 斐波那契数列
- 汉诺塔问题
- 树的遍历及相关操作

优缺点：

- 优点：实现简单
- 缺点：运行效率低，循环递归调用过程中系统为每层返回点，局部变量等开辟了栈来存储，递归太深，容易发送栈移除。

解题策略：

- 第一步：明确函数的输入输出

- 第二步：寻找递归结束条件

- 第三步：明确递归关系式，怎么通过各种递归调用来组合解决当前问题

## 分治算法

分治算法是一个很重要的算法，快速排序、归并排序等都是基于分治策略进行实现的。

分而治之，将复杂问题，分成两个或多个相似的子问题，再把子问题分成更小的子问题，直到更小的问题可以简单求解

- 二分查找
- 归并排序
- 快速排序
- 汉诺塔问题
- React 时间分片

解题策略:

- 第一步：分解，将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题

- 第二步：解决，解决各个子问题

- 第三步：合并，将各个子问题的解合并为原问题的解

## 贪心算法

总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择；贪心算法做出的选择仅仅是某种意义上的局部最优，但它在很多问题上还是能够拿到最优解或较优解。

- 最小生成树算法
- 单源最短路径的 `Dijkstra` 算法
- `Huffman` 压缩编码
- 背包问题
- 活动选择问题等

## 回溯算法

回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就会回溯回去，重新作出选择。**深度优先搜索**利用的就是回溯算法思想。

- 深度优先搜索
- 0-1背包问题
- 正则表达式匹配
- 八皇后
- 数独
- 全排列

回溯算法很简单，它就是不断的尝试，直到拿到解。它的这种算法思想，使它通常用于解决广度的搜索问题，即从一组可能的解中，选择一个满足要求的解。

## 动态规划

```js
// 以爬楼梯为例
/**
 * 第一步：如果用 dp[n] 表示第 n 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 n 级台阶的方案数等于第  *  n-1 级台阶的方案数加上第 n-2 级台阶的方案数
 * 
 * 第二步：实现需要反复执行解决的子子问题部分：dp[n] = dp[n−1] + dp[n−2]
 * 
 * 第三步：识别并求解出边界条件
 * 
 * // 第 0 级 1 种方案 
 * dp[0]=1 
 * // 第 1 级也是 1 种方案 
 * dp[1]=1
 */

let climbStairs = function(n) {
    let dp = [1, 1]
    for(let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }
    return dp[n]
}
```

动态规划也是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求子问题相互独立，而动态规划则子问题相互关联。

所以，动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，在这种情况下，分治策略会做出很多不必要的工作，它会反复求解那些公共子子问题，而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到一致的问题，从表格中获取既可，所以它无需求解每一个子子问题，避免了大量的不必要操作。

- 爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
- 背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值
- 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案
- 图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径
- 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）

解题策略:

- 定义子问题
- 实现需要反复执行解决的子子问题部分
- 识别并求解出边界条件

## 枚举算法

将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的。

解题策略:

- 确定枚举对象、枚举范围和判定条件。
- 逐一列举可能的解，验证每个解是否是问题的解。

**参考**：

- [95% 的算法都是基于这 6 种算法思想](https://juejin.cn/post/7127212015159869470)